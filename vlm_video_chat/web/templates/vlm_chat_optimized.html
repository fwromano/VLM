<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VLM Video Chat - Optimized</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@4.0.10/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        /* Left Panel - Video */
        .video-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #111111;
            position: relative;
        }
        
        .video-header {
            padding: 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #2a2a2a;
        }
        
        .video-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: #000000;
        }
        
        #videoCanvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            image-rendering: optimizeQuality;
        }
        
        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff00;
        }
        
        .status-dot.processing {
            background: #ffaa00;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Right Panel - Chat */
        .chat-panel {
            width: 450px;
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
            border-left: 1px solid #2a2a2a;
        }
        
        .chat-header {
            padding: 20px;
            background: #222222;
            border-bottom: 1px solid #2a2a2a;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .message {
            display: flex;
            flex-direction: column;
            gap: 8px;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }
        
        .message-sender {
            font-weight: 600;
            color: #4a9eff;
        }
        
        .message-sender.vlm {
            color: #00ff88;
        }
        
        .message-time {
            color: #666;
            font-size: 12px;
        }
        
        .message-content {
            background: #2a2a2a;
            padding: 12px 16px;
            border-radius: 12px;
            line-height: 1.5;
        }
        
        /* Markdown formatting */
        .message-content h1, .message-content h2, .message-content h3 {
            color: #4a9eff;
            margin: 8px 0 4px 0;
        }
        
        .message-content h1 { font-size: 1.2em; }
        .message-content h2 { font-size: 1.1em; }
        .message-content h3 { font-size: 1.05em; }
        
        .message-content p {
            margin: 4px 0;
        }
        
        .message-content ul, .message-content ol {
            margin: 8px 0;
            padding-left: 20px;
        }
        
        .message-content li {
            margin: 2px 0;
        }
        
        .message-content code {
            background: #1a1a1a;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            color: #00ff88;
        }
        
        .message-content pre {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 8px 0;
            border-left: 3px solid #4a9eff;
        }
        
        .message-content pre code {
            background: none;
            padding: 0;
            color: #ffffff;
        }
        
        .message-content blockquote {
            border-left: 3px solid #666;
            padding-left: 12px;
            margin: 8px 0;
            color: #ccc;
            font-style: italic;
        }
        
        .message-content strong {
            color: #ffffff;
            font-weight: 600;
        }
        
        .message-content em {
            color: #ddd;
            font-style: italic;
        }
        
        .message-content a {
            color: #4a9eff;
            text-decoration: none;
        }
        
        .message-content a:hover {
            text-decoration: underline;
        }
        
        .message-content table {
            border-collapse: collapse;
            margin: 8px 0;
            width: 100%;
        }
        
        .message-content th, .message-content td {
            border: 1px solid #3a3a3a;
            padding: 6px 8px;
            text-align: left;
        }
        
        .message-content th {
            background: #3a3a3a;
            font-weight: 600;
        }
        
        .message.processing .message-content {
            background: #2a3a4a;
            color: #88aacc;
            font-style: italic;
        }
        
        .message-frame {
            margin-top: 8px;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .message-frame img {
            max-width: 100%;
            height: auto;
            display: block;
            transition: opacity 0.3s ease;
        }
        
        .frame-toggle {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.7);
            border: none;
            color: #ffffff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.2s;
        }
        
        .frame-toggle:hover {
            background: rgba(0, 0, 0, 0.9);
        }
        
        .message-frame.collapsed img {
            display: none;
        }
        
        .message-frame.collapsed {
            background: #1a1a1a;
            border: 2px dashed #3a3a3a;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .message-frame.collapsed .frame-toggle {
            background: rgba(74, 158, 255, 0.8);
            position: static;
            margin: 0;
        }
        
        .frame-placeholder {
            display: none;
            color: #666;
            font-size: 14px;
            text-align: center;
        }
        
        .message-frame.collapsed .frame-placeholder {
            display: block;
        }
        
        .conversation-group {
            border-left: 3px solid #2a2a2a;
            padding-left: 15px;
            margin: 20px 0;
            position: relative;
        }
        
        .conversation-group.active {
            border-left-color: #4a9eff;
        }
        
        .conversation-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: #2a2a2a;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .conversation-header:hover {
            background: #3a3a3a;
        }
        
        .conversation-toggle {
            font-size: 12px;
            color: #888;
            transition: transform 0.2s;
        }
        
        .conversation-group.collapsed .conversation-toggle {
            transform: rotate(-90deg);
        }
        
        .conversation-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
            max-height: 1000px; /* Default open state */
        }
        
        .conversation-group.collapsed .conversation-content {
            max-height: 0;
        }
        
        /* Input Area */
        .input-area {
            padding: 20px;
            background: #222222;
            border-top: 1px solid #2a2a2a;
        }
        
        .quick-prompts {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .quick-prompt-btn {
            padding: 6px 12px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 16px;
            color: #ffffff;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .quick-prompt-btn:hover {
            background: #3a3a3a;
            border-color: #4a4a4a;
            transform: translateY(-1px);
        }
        
        .input-container {
            display: flex;
            gap: 10px;
        }
        
        #messageInput {
            flex: 1;
            padding: 12px 16px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 24px;
            color: #ffffff;
            font-size: 14px;
            resize: none;
            outline: none;
            transition: border-color 0.2s;
        }
        
        #messageInput:focus {
            border-color: #4a9eff;
        }
        
        #sendButton {
            padding: 12px 24px;
            background: #4a9eff;
            border: none;
            border-radius: 24px;
            color: #ffffff;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        #sendButton:hover:not(:disabled) {
            background: #3a8eef;
            transform: translateY(-1px);
        }
        
        #sendButton:disabled {
            background: #3a3a3a;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        /* Performance Monitor */
        .performance-monitor {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 12px;
            font-family: monospace;
            backdrop-filter: blur(10px);
            display: none;
        }
        
        .performance-monitor.visible {
            display: block;
        }
        
        .perf-metric {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin: 2px 0;
        }
        
        .perf-label {
            color: #888;
        }
        
        .perf-value {
            color: #00ff88;
        }
        
        /* Scrollbar Styling */
        .chat-messages::-webkit-scrollbar {
            width: 8px;
        }
        
        .chat-messages::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .chat-messages::-webkit-scrollbar-thumb {
            background: #3a3a3a;
            border-radius: 4px;
        }
        
        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #4a4a4a;
        }
        
        /* Loading Animation */
        .loading-dots {
            display: inline-flex;
            gap: 4px;
        }
        
        .loading-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #4a9eff;
            animation: loadingBounce 1.4s ease-in-out infinite;
        }
        
        .loading-dot:nth-child(2) { animation-delay: 0.1s; }
        .loading-dot:nth-child(3) { animation-delay: 0.2s; }
        
        @keyframes loadingBounce {
            0%, 80%, 100% { transform: scale(1); opacity: 0.5; }
            40% { transform: scale(1.3); opacity: 1; }
        }
        
        /* Streaming cursor animation */
        .stream-cursor {
            animation: blink 1s infinite;
            color: #4a9eff;
            font-weight: bold;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .streaming .message-content {
            background: linear-gradient(90deg, #2a2a2a 0%, #2a3a4a 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Video Panel -->
        <div class="video-panel">
            <div class="video-header">
                <h2>VLM Video Chat - Optimized</h2>
                <p style="color: #666; margin-top: 5px;">
                    {{ config.model_name }} | 
                    {% if gpu_available %}GPU Accelerated{% else %}CPU Mode{% endif %}
                </p>
            </div>
            
            <div class="video-container">
                <canvas id="videoCanvas"></canvas>
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">Connecting...</span>
                </div>
                
                <div class="performance-monitor" id="perfMonitor">
                    <div class="perf-metric">
                        <span class="perf-label">FPS:</span>
                        <span class="perf-value" id="fpsValue">0</span>
                    </div>
                    <div class="perf-metric">
                        <span class="perf-label">GPU Memory:</span>
                        <span class="perf-value" id="gpuMemValue">N/A</span>
                    </div>
                    <div class="perf-metric">
                        <span class="perf-label">Queue:</span>
                        <span class="perf-value" id="queueValue">0</span>
                    </div>
                    <div class="perf-metric">
                        <span class="perf-label">Latency:</span>
                        <span class="perf-value" id="latencyValue">0ms</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Chat Panel -->
        <div class="chat-panel">
            <div class="chat-header">
                <h3>Chat</h3>
                <p style="color: #666; margin-top: 5px; font-size: 14px;">
                    Ask questions about what you see
                </p>
            </div>
            
            <div class="chat-messages" id="chatMessages"></div>
            
            <div class="input-area">
                <div class="quick-prompts">
                    <button class="quick-prompt-btn" onclick="sendQuickPrompt('What do you see?')">
                        What do you see?
                    </button>
                    <button class="quick-prompt-btn" onclick="sendQuickPrompt('Describe the scene')">
                        Describe the scene
                    </button>
                    <button class="quick-prompt-btn" onclick="sendQuickPrompt('What color is the main object?')">
                        What color?
                    </button>
                    <button class="quick-prompt-btn" onclick="sendQuickPrompt('How many people are visible?')">
                        How many people?
                    </button>
                    <button class="quick-prompt-btn" onclick="sendQuickPrompt('What is happening?')">
                        What's happening?
                    </button>
                </div>
                
                <div class="input-container">
                    <textarea 
                        id="messageInput" 
                        placeholder="Type your question..."
                        rows="1"
                        onkeydown="handleKeyPress(event)"
                    ></textarea>
                    <button id="sendButton" onclick="sendMessage()">Send</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Optimized WebSocket connection with reconnection logic
        class OptimizedVLMClient {
            constructor() {
                this.socket = null;
                this.canvas = document.getElementById('videoCanvas');
                this.ctx = this.canvas.getContext('2d', { 
                    alpha: false,
                    desynchronized: true  // Better performance
                });
                
                // Performance tracking
                this.frameCount = 0;
                this.lastFpsUpdate = Date.now();
                this.fps = 0;
                this.latencies = [];
                
                // Image caching
                this.imageCache = new Map();
                this.maxCacheSize = 10;
                
                // Conversation management
                this.currentConversationId = null;
                this.conversations = new Map();
                this.conversationCounter = 0;
                
                // Initialize connection
                this.connect();
                
                // Setup performance monitoring
                this.setupPerformanceMonitoring();
                
                // Setup markdown renderer
                this.setupMarkdownRenderer();
            }
            
            connect() {
                this.socket = io();
                
                this.socket.on('connect', () => {
                    console.log('Connected to server');
                    this.updateStatus('Ready', false);
                    this.addSystemMessage('Connected to VLM server');
                });
                
                this.socket.on('disconnect', () => {
                    console.log('Disconnected from server');
                    this.updateStatus('Disconnected', false);
                    this.addSystemMessage('Disconnected from server');
                });
                
                this.socket.on('video_frame', (data) => {
                    this.renderFrame(data.frame);
                    this.updateFPS();
                });
                
                this.socket.on('chat_message', (data) => {
                    this.addMessage(data);
                });
                
                this.socket.on('analysis_response', (data) => {
                    this.handleResponse(data);
                });
                
                this.socket.on('stream_start', (data) => {
                    this.startStreamingResponse(data.conversation_id);
                });
                
                this.socket.on('stream_token', (data) => {
                    this.appendStreamToken(data.conversation_id, data.token);
                });
                
                this.socket.on('stream_complete', (data) => {
                    this.completeStreamingResponse(data.conversation_id);
                });
                
                this.socket.on('stream_error', (data) => {
                    this.handleStreamError(data.conversation_id, data.error);
                });
                
                this.socket.on('status_update', (data) => {
                    this.updateStatus(
                        data.status === 'processing' ? 'Processing...' : 'Ready',
                        data.status === 'processing'
                    );
                });
                
                this.socket.on('performance_metrics', (data) => {
                    this.updatePerformanceMetrics(data);
                });
                
                this.socket.on('error', (data) => {
                    this.showError(data.message);
                });
            }
            
            renderFrame(frameData) {
                const img = new Image();
                img.onload = () => {
                    this.canvas.width = img.width;
                    this.canvas.height = img.height;
                    this.ctx.drawImage(img, 0, 0);
                };
                img.src = `data:image/jpeg;base64,${frameData}`;
            }
            
            updateFPS() {
                this.frameCount++;
                const now = Date.now();
                const elapsed = now - this.lastFpsUpdate;
                
                if (elapsed >= 1000) {
                    this.fps = Math.round((this.frameCount * 1000) / elapsed);
                    document.getElementById('fpsValue').textContent = `${this.fps} fps`;
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                }
            }
            
            setupPerformanceMonitoring() {
                // Request metrics every 2 seconds
                setInterval(() => {
                    if (this.socket && this.socket.connected) {
                        this.socket.emit('get_performance_metrics');
                    }
                }, 2000);
                
                // Toggle performance monitor with 'P' key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'p' || e.key === 'P') {
                        const monitor = document.getElementById('perfMonitor');
                        monitor.classList.toggle('visible');
                    }
                });
            }
            
            updatePerformanceMetrics(data) {
                const gpuMem = data.gpu_memory_allocated 
                    ? `${data.gpu_memory_allocated.toFixed(2)}GB` 
                    : 'N/A';
                document.getElementById('gpuMemValue').textContent = gpuMem;
                document.getElementById('queueValue').textContent = data.queue_size;
                
                // Calculate average latency
                if (this.latencies.length > 0) {
                    const avgLatency = this.latencies.reduce((a, b) => a + b) / this.latencies.length;
                    document.getElementById('latencyValue').textContent = `${Math.round(avgLatency)}ms`;
                }
            }
            
            addMessage(data) {
                const messagesDiv = document.getElementById('chatMessages');
                
                // Handle conversation grouping
                if (data.sender === 'You' && data.frame) {
                    // Start new conversation
                    this.startNewConversation(data);
                    return;
                } else if (data.sender === 'VLM' && !data.processing) {
                    // Complete current conversation
                    this.completeCurrentConversation(data);
                    return;
                } else if (data.processing) {
                    // Update processing state
                    this.updateProcessingState(data);
                    return;
                }
                
                // Regular message without frame
                this.addRegularMessage(data, messagesDiv);
            }
            
            startNewConversation(data) {
                const messagesDiv = document.getElementById('chatMessages');
                
                // Use conversation_id from data if available, otherwise generate
                const conversationId = data.conversation_id || `conv_${++this.conversationCounter}`;
                this.currentConversationId = conversationId;
                
                // Create conversation group
                const conversationDiv = document.createElement('div');
                conversationDiv.className = 'conversation-group active';
                conversationDiv.id = conversationId;
                
                const format = data.frame_format || 'jpeg';
                const mimeType = format === 'webp' ? 'image/webp' : 'image/jpeg';
                
                conversationDiv.innerHTML = `
                    <div class="conversation-header" onclick="toggleConversation('${conversationId}')">
                        <span class="conversation-toggle">▼</span>
                        <span>Q: ${data.message}</span>
                        <span style="margin-left: auto; font-size: 12px; color: #666;">${data.timestamp}</span>
                    </div>
                    <div class="conversation-content">
                        <div class="message-frame collapsed" id="frame_${conversationId}">
                            <img src="data:${mimeType};base64,${data.frame}" 
                                 width="${data.frame_width}" 
                                 height="${data.frame_height}"
                                 loading="lazy">
                            <div class="frame-placeholder">
                                📷 Show Image
                            </div>
                            <button class="frame-toggle" onclick="toggleFrame('frame_${conversationId}')">
                                Show
                            </button>
                        </div>
                        <div class="message processing" id="processing_${conversationId}">
                            <div class="message-header">
                                <span class="message-sender vlm">VLM</span>
                                <span class="message-time">${data.timestamp}</span>
                            </div>
                            <div class="message-content" id="content_${conversationId}">
                                Analyzing image...
                                <div class="loading-dots">
                                    <div class="loading-dot"></div>
                                    <div class="loading-dot"></div>
                                    <div class="loading-dot"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                messagesDiv.appendChild(conversationDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                
                // Store conversation data
                this.conversations.set(conversationId, {
                    question: data.message,
                    timestamp: data.timestamp,
                    frame: data.frame,
                    frame_format: format,
                    frame_width: data.frame_width,
                    frame_height: data.frame_height,
                    accumulated_text: '',
                    start_time: Date.now()
                });
            }
            
            completeCurrentConversation(data) {
                if (!this.currentConversationId) return;
                
                const processingMsg = document.getElementById(`processing_${this.currentConversationId}`);
                if (processingMsg) {
                    // Format response with markdown detection
                    const formattedResponse = this.detectAndFormatMarkdown(data.response);
                    const timingInfo = `<small style="color: #666;">(${data.processing_time.toFixed(2)}s)</small>`;
                    
                    processingMsg.innerHTML = `
                        <div class="message-header">
                            <span class="message-sender vlm">VLM</span>
                            <span class="message-time">${data.timestamp}</span>
                        </div>
                        <div class="message-content">
                            ${formattedResponse} ${timingInfo}
                        </div>
                    `;
                    processingMsg.classList.remove('processing');
                }
                
                // Mark conversation as complete
                const conversationDiv = document.getElementById(this.currentConversationId);
                if (conversationDiv) {
                    conversationDiv.classList.remove('active');
                }
                
                this.currentConversationId = null;
                
                const messagesDiv = document.getElementById('chatMessages');
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
            
            updateProcessingState(data) {
                // Processing message is already shown in startNewConversation
                // Just update if needed
            }
            
            addRegularMessage(data, messagesDiv) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${data.processing ? 'processing' : ''}`;
                
                const processingIndicator = data.processing 
                    ? '<div class="loading-dots"><div class="loading-dot"></div><div class="loading-dot"></div><div class="loading-dot"></div></div>' 
                    : '';
                
                // Format message content with markdown if it's from VLM
                const messageContent = data.sender === 'VLM' && !data.processing 
                    ? this.detectAndFormatMarkdown(data.message)
                    : this.escapeHtml(data.message);
                
                messageDiv.innerHTML = `
                    <div class="message-header">
                        <span class="message-sender ${data.sender === 'VLM' ? 'vlm' : ''}">${data.sender}</span>
                        <span class="message-time">${data.timestamp}</span>
                    </div>
                    <div class="message-content">
                        ${messageContent} ${processingIndicator}
                    </div>
                `;
                
                messagesDiv.appendChild(messageDiv);
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
            
            handleResponse(data) {
                // Track latency
                const latency = data.processing_time * 1000;
                this.latencies.push(latency);
                if (this.latencies.length > 10) {
                    this.latencies.shift();
                }
                
                // Complete current conversation
                this.completeCurrentConversation(data);
            }
            
            updateStatus(text, processing) {
                document.getElementById('statusText').textContent = text;
                const dot = document.getElementById('statusDot');
                dot.className = processing ? 'status-dot processing' : 'status-dot';
            }
            
            addSystemMessage(message) {
                console.log(`System: ${message}`);
            }
            
            showError(message) {
                this.addMessage({
                    sender: 'System',
                    message: `Error: ${message}`,
                    timestamp: new Date().toLocaleTimeString()
                });
            }
            
            setupMarkdownRenderer() {
                // Configure marked options for better security and styling
                marked.setOptions({
                    breaks: true,
                    gfm: true,
                    sanitize: false, // We control the input
                    smartLists: true,
                    smartypants: true
                });
            }
            
            detectAndFormatMarkdown(text) {
                // Common markdown patterns that VLMs might use
                const markdownPatterns = [
                    /#{1,3}\s+/,           // Headers
                    /\*\*.*\*\*/,          // Bold
                    /\*.*\*/,              // Italic  
                    /`.*`/,                // Inline code
                    /```[\s\S]*```/,       // Code blocks
                    /^\s*[-\*\+]\s+/m,     // Lists
                    /^\s*\d+\.\s+/m,       // Numbered lists
                    />\s+/m,               // Blockquotes
                    /\[.*\]\(.*\)/,        // Links
                    /\|.*\|/               // Tables
                ];
                
                // Check if text contains markdown patterns
                const hasMarkdown = markdownPatterns.some(pattern => pattern.test(text));
                
                if (hasMarkdown) {
                    try {
                        return marked.parse(text);
                    } catch (error) {
                        console.warn('Markdown parsing failed:', error);
                        return this.escapeHtml(text);
                    }
                }
                
                // Return escaped HTML for plain text
                return this.escapeHtml(text);
            }
            
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            // Streaming response handlers
            startStreamingResponse(conversationId) {
                const contentDiv = document.getElementById(`content_${conversationId}`);
                if (contentDiv) {
                    contentDiv.innerHTML = `
                        <span id="stream_text_${conversationId}"></span>
                        <span class="stream-cursor">|</span>
                    `;
                }
                
                // Mark conversation as streaming
                const conversation = this.conversations.get(conversationId);
                if (conversation) {
                    conversation.streaming = true;
                    conversation.accumulated_text = '';
                }
            }
            
            appendStreamToken(conversationId, token) {
                const textSpan = document.getElementById(`stream_text_${conversationId}`);
                const conversation = this.conversations.get(conversationId);
                
                if (textSpan && conversation) {
                    // Accumulate text
                    conversation.accumulated_text += token;
                    
                    // Display as escaped HTML for now (markdown applied on completion)
                    textSpan.innerHTML = this.escapeHtml(conversation.accumulated_text);
                    
                    // Auto-scroll to keep new text visible
                    const messagesDiv = document.getElementById('chatMessages');
                    messagesDiv.scrollTop = messagesDiv.scrollHeight;
                }
            }
            
            completeStreamingResponse(conversationId) {
                const contentDiv = document.getElementById(`content_${conversationId}`);
                const conversation = this.conversations.get(conversationId);
                
                if (contentDiv && conversation) {
                    // Calculate total time
                    const totalTime = (Date.now() - conversation.start_time) / 1000;
                    
                    // Apply markdown formatting to final text
                    const formattedText = this.detectAndFormatMarkdown(conversation.accumulated_text);
                    const timingInfo = `<small style="color: #666;">(${totalTime.toFixed(2)}s)</small>`;
                    
                    // Update with final formatted content
                    contentDiv.innerHTML = `${formattedText} ${timingInfo}`;
                    
                    // Remove processing class
                    const processingMsg = document.getElementById(`processing_${conversationId}`);
                    if (processingMsg) {
                        processingMsg.classList.remove('processing');
                    }
                    
                    // Mark conversation as complete
                    const conversationDiv = document.getElementById(conversationId);
                    if (conversationDiv) {
                        conversationDiv.classList.remove('active');
                    }
                    
                    conversation.streaming = false;
                }
                
                // Clear current conversation
                if (this.currentConversationId === conversationId) {
                    this.currentConversationId = null;
                }
            }
            
            handleStreamError(conversationId, error) {
                const contentDiv = document.getElementById(`content_${conversationId}`);
                if (contentDiv) {
                    contentDiv.innerHTML = `
                        <span style="color: #ff6b6b;">Error: ${this.escapeHtml(error)}</span>
                    `;
                }
                
                // Mark as completed with error
                this.completeStreamingResponse(conversationId);
            }
        }
        
        // Initialize client
        const client = new OptimizedVLMClient();
        
        // Global functions for UI interactions
        function toggleConversation(conversationId) {
            const conversationDiv = document.getElementById(conversationId);
            if (conversationDiv) {
                conversationDiv.classList.toggle('collapsed');
                
                // Update content max-height for animation
                const content = conversationDiv.querySelector('.conversation-content');
                if (conversationDiv.classList.contains('collapsed')) {
                    content.style.maxHeight = '0';
                } else {
                    content.style.maxHeight = content.scrollHeight + 'px';
                }
            }
        }
        
        function toggleFrame(frameId) {
            const frameDiv = document.getElementById(frameId);
            const button = frameDiv.querySelector('.frame-toggle');
            const img = frameDiv.querySelector('img');
            const placeholder = frameDiv.querySelector('.frame-placeholder');
            
            if (frameDiv.classList.contains('collapsed')) {
                // Show image
                frameDiv.classList.remove('collapsed');
                button.textContent = 'Hide';
                
                // Smooth transition back to original size
                setTimeout(() => {
                    frameDiv.style.minHeight = 'auto';
                }, 300);
            } else {
                // Hide image
                frameDiv.classList.add('collapsed');
                button.textContent = 'Show';
                
                // Update placeholder
                if (placeholder) {
                    placeholder.innerHTML = `📷 Show Image`;
                }
            }
        }
        
        // Message handling functions
        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (message && client.socket.connected) {
                client.socket.emit('send_message', { message });
                input.value = '';
                input.style.height = 'auto';
                document.getElementById('sendButton').disabled = true;
                
                setTimeout(() => {
                    document.getElementById('sendButton').disabled = false;
                }, 1000);
            }
        }
        
        function sendQuickPrompt(prompt) {
            document.getElementById('messageInput').value = prompt;
            sendMessage();
        }
        
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
        // Auto-resize textarea
        document.getElementById('messageInput').addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });
        
        // Focus input on load
        window.addEventListener('load', () => {
            document.getElementById('messageInput').focus();
        });
    </script>
</body>
</html>